// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// HostConfigAllOf1 host config all of1
// swagger:model hostConfigAllOf1
type HostConfigAllOf1 struct {

	// Automatically remove the container when the container's process exits. This has no effect if `RestartPolicy` is set.
	AutoRemove bool `json:"AutoRemove,omitempty"`

	// A list of volume bindings for this container. Each volume binding is a string in one of these forms:
	//
	// - `host-src:container-dest` to bind-mount a host path into the container. Both `host-src`, and `container-dest` must be an _absolute_ path.
	// - `host-src:container-dest:ro` to make the bind mount read-only inside the container. Both `host-src`, and `container-dest` must be an _absolute_ path.
	// - `volume-name:container-dest` to bind-mount a volume managed by a volume driver into the container. `container-dest` must be an _absolute_ path.
	// - `volume-name:container-dest:ro` to mount the volume read-only inside the container.  `container-dest` must be an _absolute_ path.
	//
	Binds []string `json:"Binds"`

	// A list of kernel capabilities to add to the container.
	CapAdd []string `json:"CapAdd"`

	// A list of kernel capabilities to drop from the container.
	CapDrop []string `json:"CapDrop"`

	// Cgroup to use for the container.
	Cgroup string `json:"Cgroup,omitempty"`

	// Initial console size, as an `[height, width]` array. (Windows only)
	// Max Items: 2
	// Min Items: 2
	ConsoleSize []*int64 `json:"ConsoleSize"`

	// Path to a file where the container ID is written
	ContainerIDFile string `json:"ContainerIDFile,omitempty"`

	// A list of DNS servers for the container to use.
	DNS []string `json:"Dns"`

	// A list of DNS options.
	DNSOptions []string `json:"DnsOptions"`

	// A list of DNS search domains.
	DNSSearch []string `json:"DnsSearch"`

	// A list of hostnames/IP mappings to add to the container's `/etc/hosts` file. Specified in the form `["hostname:IP"]`.
	//
	ExtraHosts []string `json:"ExtraHosts"`

	// A list of additional groups that the container process will run as.
	GroupAdd []string `json:"GroupAdd"`

	// IPC sharing mode for the container. Possible values are:
	//
	// - `"none"`: own private IPC namespace, with /dev/shm not mounted
	// - `"private"`: own private IPC namespace
	// - `"shareable"`: own private IPC namespace, with a possibility to share it with other containers
	// - `"container:<name|id>"`: join another (shareable) container's IPC namespace
	// - `"host"`: use the host system's IPC namespace
	//
	// If not specified, daemon default is used, which can either be `"private"`
	// or `"shareable"`, depending on daemon version and configuration.
	//
	IpcMode string `json:"IpcMode,omitempty"`

	// Isolation technology of the container. (Windows only)
	Isolation string `json:"Isolation,omitempty"`

	// A list of links for the container in the form `container_name:alias`.
	Links []string `json:"Links"`

	// log config
	LogConfig *HostConfigAllOf1LogConfig `json:"LogConfig,omitempty"`

	// mounts
	Mounts HostConfigAllOf1Mounts `json:"Mounts"`

	// Network mode to use for this container. Supported standard values are: `bridge`, `host`, `none`, and `container:<name|id>`. Any other value is taken as a custom network's name to which this container should connect to.
	NetworkMode string `json:"NetworkMode,omitempty"`

	// An integer value containing the score given to the container in order to tune OOM killer preferences.
	OomScoreAdj int64 `json:"OomScoreAdj,omitempty"`

	// Set the PID (Process) Namespace mode for the container. It can be either:
	//
	// - `"container:<name|id>"`: joins another container's PID namespace
	// - `"host"`: use the host's PID namespace inside the container
	//
	PidMode string `json:"PidMode,omitempty"`

	// port bindings
	PortBindings PortMap `json:"PortBindings,omitempty"`

	// Gives the container full access to the host.
	Privileged bool `json:"Privileged,omitempty"`

	// Allocates an ephemeral host port for all of a container's
	// exposed ports.
	//
	// Ports are de-allocated when the container stops and allocated when the container starts.
	// The allocated port might be changed when restarting the container.
	//
	// The port is selected from the ephemeral port range that depends on the kernel.
	// For example, on Linux the range is defined by `/proc/sys/net/ipv4/ip_local_port_range`.
	//
	PublishAllPorts bool `json:"PublishAllPorts,omitempty"`

	// Mount the container's root filesystem as read only.
	ReadonlyRootfs bool `json:"ReadonlyRootfs,omitempty"`

	// restart policy
	RestartPolicy *RestartPolicy `json:"RestartPolicy,omitempty"`

	// Runtime to use with this container.
	Runtime string `json:"Runtime,omitempty"`

	// A list of string values to customize labels for MLS systems, such as SELinux.
	SecurityOpt []string `json:"SecurityOpt"`

	// Size of `/dev/shm` in bytes. If omitted, the system uses 64MB.
	// Minimum: 0
	ShmSize *int64 `json:"ShmSize,omitempty"`

	// Storage driver options for this container, in the form `{"size": "120G"}`.
	//
	StorageOpt map[string]string `json:"StorageOpt,omitempty"`

	// A list of kernel parameters (sysctls) to set in the container. For example: `{"net.ipv4.ip_forward": "1"}`
	//
	Sysctls map[string]string `json:"Sysctls,omitempty"`

	// A map of container directories which should be replaced by tmpfs mounts, and their corresponding mount options. For example: `{ "/run": "rw,noexec,nosuid,size=65536k" }`.
	//
	Tmpfs map[string]string `json:"Tmpfs,omitempty"`

	// UTS namespace to use for the container.
	UTSMode string `json:"UTSMode,omitempty"`

	// Sets the usernamespace mode for the container when usernamespace remapping option is enabled.
	UsernsMode string `json:"UsernsMode,omitempty"`

	// Driver that this container uses to mount volumes.
	VolumeDriver string `json:"VolumeDriver,omitempty"`

	// A list of volumes to inherit from another container, specified in the form `<container name>[:<ro|rw>]`.
	VolumesFrom []string `json:"VolumesFrom"`
}

// Validate validates this host config all of1
func (m *HostConfigAllOf1) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBinds(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateCapAdd(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateCapDrop(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateConsoleSize(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateDNS(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateDNSOptions(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateDNSSearch(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateExtraHosts(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateGroupAdd(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateIsolation(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateLinks(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateLogConfig(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateRestartPolicy(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateSecurityOpt(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateShmSize(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateVolumesFrom(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *HostConfigAllOf1) validateBinds(formats strfmt.Registry) error {

	if swag.IsZero(m.Binds) { // not required
		return nil
	}

	return nil
}

func (m *HostConfigAllOf1) validateCapAdd(formats strfmt.Registry) error {

	if swag.IsZero(m.CapAdd) { // not required
		return nil
	}

	return nil
}

func (m *HostConfigAllOf1) validateCapDrop(formats strfmt.Registry) error {

	if swag.IsZero(m.CapDrop) { // not required
		return nil
	}

	return nil
}

func (m *HostConfigAllOf1) validateConsoleSize(formats strfmt.Registry) error {

	if swag.IsZero(m.ConsoleSize) { // not required
		return nil
	}

	iConsoleSizeSize := int64(len(m.ConsoleSize))

	if err := validate.MinItems("ConsoleSize", "body", iConsoleSizeSize, 2); err != nil {
		return err
	}

	if err := validate.MaxItems("ConsoleSize", "body", iConsoleSizeSize, 2); err != nil {
		return err
	}

	for i := 0; i < len(m.ConsoleSize); i++ {

		if swag.IsZero(m.ConsoleSize[i]) { // not required
			continue
		}

		if err := validate.MinimumInt("ConsoleSize"+"."+strconv.Itoa(i), "body", int64(*m.ConsoleSize[i]), 0, false); err != nil {
			return err
		}

	}

	return nil
}

func (m *HostConfigAllOf1) validateDNS(formats strfmt.Registry) error {

	if swag.IsZero(m.DNS) { // not required
		return nil
	}

	return nil
}

func (m *HostConfigAllOf1) validateDNSOptions(formats strfmt.Registry) error {

	if swag.IsZero(m.DNSOptions) { // not required
		return nil
	}

	return nil
}

func (m *HostConfigAllOf1) validateDNSSearch(formats strfmt.Registry) error {

	if swag.IsZero(m.DNSSearch) { // not required
		return nil
	}

	return nil
}

func (m *HostConfigAllOf1) validateExtraHosts(formats strfmt.Registry) error {

	if swag.IsZero(m.ExtraHosts) { // not required
		return nil
	}

	return nil
}

func (m *HostConfigAllOf1) validateGroupAdd(formats strfmt.Registry) error {

	if swag.IsZero(m.GroupAdd) { // not required
		return nil
	}

	return nil
}

var hostConfigAllOf1TypeIsolationPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["default","process","hyperv"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		hostConfigAllOf1TypeIsolationPropEnum = append(hostConfigAllOf1TypeIsolationPropEnum, v)
	}
}

const (

	// HostConfigAllOf1IsolationDefault captures enum value "default"
	HostConfigAllOf1IsolationDefault string = "default"

	// HostConfigAllOf1IsolationProcess captures enum value "process"
	HostConfigAllOf1IsolationProcess string = "process"

	// HostConfigAllOf1IsolationHyperv captures enum value "hyperv"
	HostConfigAllOf1IsolationHyperv string = "hyperv"
)

// prop value enum
func (m *HostConfigAllOf1) validateIsolationEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, hostConfigAllOf1TypeIsolationPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *HostConfigAllOf1) validateIsolation(formats strfmt.Registry) error {

	if swag.IsZero(m.Isolation) { // not required
		return nil
	}

	// value enum
	if err := m.validateIsolationEnum("Isolation", "body", m.Isolation); err != nil {
		return err
	}

	return nil
}

func (m *HostConfigAllOf1) validateLinks(formats strfmt.Registry) error {

	if swag.IsZero(m.Links) { // not required
		return nil
	}

	return nil
}

func (m *HostConfigAllOf1) validateLogConfig(formats strfmt.Registry) error {

	if swag.IsZero(m.LogConfig) { // not required
		return nil
	}

	if m.LogConfig != nil {

		if err := m.LogConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("LogConfig")
			}
			return err
		}

	}

	return nil
}

func (m *HostConfigAllOf1) validateRestartPolicy(formats strfmt.Registry) error {

	if swag.IsZero(m.RestartPolicy) { // not required
		return nil
	}

	if m.RestartPolicy != nil {

		if err := m.RestartPolicy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("RestartPolicy")
			}
			return err
		}

	}

	return nil
}

func (m *HostConfigAllOf1) validateSecurityOpt(formats strfmt.Registry) error {

	if swag.IsZero(m.SecurityOpt) { // not required
		return nil
	}

	return nil
}

func (m *HostConfigAllOf1) validateShmSize(formats strfmt.Registry) error {

	if swag.IsZero(m.ShmSize) { // not required
		return nil
	}

	if err := validate.MinimumInt("ShmSize", "body", int64(*m.ShmSize), 0, false); err != nil {
		return err
	}

	return nil
}

func (m *HostConfigAllOf1) validateVolumesFrom(formats strfmt.Registry) error {

	if swag.IsZero(m.VolumesFrom) { // not required
		return nil
	}

	return nil
}

// MarshalBinary interface implementation
func (m *HostConfigAllOf1) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *HostConfigAllOf1) UnmarshalBinary(b []byte) error {
	var res HostConfigAllOf1
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
