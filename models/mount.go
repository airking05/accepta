// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Mount mount
// swagger:model Mount
type Mount struct {

	// bind options
	BindOptions *MountBindOptions `json:"BindOptions,omitempty"`

	// The consistency requirement for the mount: `default`, `consistent`, `cached`, or `delegated`.
	Consistency string `json:"Consistency,omitempty"`

	// Whether the mount should be read-only.
	ReadOnly bool `json:"ReadOnly,omitempty"`

	// Mount source (e.g. a volume name, a host path).
	Source string `json:"Source,omitempty"`

	// Container path.
	Target string `json:"Target,omitempty"`

	// tmpfs options
	TmpfsOptions *MountTmpfsOptions `json:"TmpfsOptions,omitempty"`

	// The mount type. Available types:
	//
	// - `bind` Mounts a file or directory from the host into the container. Must exist prior to creating the container.
	// - `volume` Creates a volume with the given name and options (or uses a pre-existing volume with the same name and options). These are **not** removed when the container is removed.
	// - `tmpfs` Create a tmpfs with the given options. The mount source cannot be specified for tmpfs.
	//
	Type string `json:"Type,omitempty"`

	// volume options
	VolumeOptions *MountVolumeOptions `json:"VolumeOptions,omitempty"`
}

// Validate validates this mount
func (m *Mount) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBindOptions(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateTmpfsOptions(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateVolumeOptions(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Mount) validateBindOptions(formats strfmt.Registry) error {

	if swag.IsZero(m.BindOptions) { // not required
		return nil
	}

	if m.BindOptions != nil {

		if err := m.BindOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("BindOptions")
			}
			return err
		}

	}

	return nil
}

func (m *Mount) validateTmpfsOptions(formats strfmt.Registry) error {

	if swag.IsZero(m.TmpfsOptions) { // not required
		return nil
	}

	if m.TmpfsOptions != nil {

		if err := m.TmpfsOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("TmpfsOptions")
			}
			return err
		}

	}

	return nil
}

var mountTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["bind","volume","tmpfs"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		mountTypeTypePropEnum = append(mountTypeTypePropEnum, v)
	}
}

const (

	// MountTypeBind captures enum value "bind"
	MountTypeBind string = "bind"

	// MountTypeVolume captures enum value "volume"
	MountTypeVolume string = "volume"

	// MountTypeTmpfs captures enum value "tmpfs"
	MountTypeTmpfs string = "tmpfs"
)

// prop value enum
func (m *Mount) validateTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, mountTypeTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *Mount) validateType(formats strfmt.Registry) error {

	if swag.IsZero(m.Type) { // not required
		return nil
	}

	// value enum
	if err := m.validateTypeEnum("Type", "body", m.Type); err != nil {
		return err
	}

	return nil
}

func (m *Mount) validateVolumeOptions(formats strfmt.Registry) error {

	if swag.IsZero(m.VolumeOptions) { // not required
		return nil
	}

	if m.VolumeOptions != nil {

		if err := m.VolumeOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("VolumeOptions")
			}
			return err
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *Mount) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Mount) UnmarshalBinary(b []byte) error {
	var res Mount
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
